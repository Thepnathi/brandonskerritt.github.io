---
title: "Timsort"
categories:
  - blog
---

Timsort is a sorting algorithm that is efficient for real-world data and not created in a academic laboratory. Timsort was created by Tim Peters for the Python programming language in 2001. Timsort first analyses the list it is trying to sort and then chooses an approach based on the list.

Since the algorithm has been invented it has been used as the default sorting algorithm in Python, Java, the Android Platform, and in versions of GNU.

Timsort was designed to use already-ordered elements that already exist in most real-world data. It calls these already-ordered elements "natural runs". It iterates over the data collecting the elements into runs, and simultaneously merging those runs together into one.

# The array has fewer than 64 elements in it

If the array has fewer than 64 elements in it, timsort will execute an insertion sort.

An insertion sort is a simple sort which is most effective on small lists. It is quite slow at larger lists, but very fast with small lists. The idea of an insertion sort is as follows:

** Look at elements one by one
** Build up sorted list by inserting the element at the correct location

Here's a trace table showing how insertion sort would sort the list [34, 10, 64, 51, 32, 21]

|       [34, 10, 64, 51, 32, 21]       | No. shifted to right |
| ------------------------------------ | -------------------- |
| [34, 10, 64, 51, 32, 21]             | Nothing yet |
| [10, **34**, 64, 51, 32, 21]             | 34 |
| [**10**, **34**, 64, 51, 32, 21]         | Nothing yet |
| [**10**, **34**, **51**, 64, 32, 21]       | 64 |
| [**10**, **32**, **34**, **51**, **64**, 21]   | 34, 51, 64 |
| [**10**, **21**, **32**, **34**, **51**, **64**] | 32, 34, 51, 64 |

In this instance we are inserting the newly sorted elements into a new sub-array, which starts at the start of the array.

Here's a gif showing insertion sort:

![img](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif)

# More about runs

he run is a very important concept for Timsort. If you have an array longer than 64 elements, the algorithm will take a first pass through the array checking for chunks that are stricty increasing or strictly decreasing (if the chunk is decreasing, it will be reversed).

If these chunks are longer than a certain size, known as minrun, which is determined based on the size of the array,1 then this is a natural runâ€“it occured naturally in your array. If the chunk is shorter than minrun, you grab minrun - len(chunk) items ahead of your chunk, and perform a binary insertion sort to create an artificial run.

After this, what you have is an array of sorted chunks of varying lengths. If your data was totally random, then chunks will probably all be close to the minrun length. If not, you could have natural runs of wildly varying lengths:

Timsort iterates over the data looking for natural runs of at least two elements that are either non-descending (each element is greater than or equal to its predecessor) or strictly descending (each element is less than its predecessor). Descending runs are later blindly reversed, so the strict order maintains the algorithm's stability; i.e., equal elements won't be reversed. Note that any two elements are guaranteed to be either descending or non-descending.

A reference to each run is then pushed onto a stack.

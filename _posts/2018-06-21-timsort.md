---
title: "Timsort"
categories:
  - blog
---

Timsort is a sorting algorithm that is efficient for real-world data and not created in a academic laboratory. Timsort was created by Tim Peters for the Python programming language in 2001. Timsort first analyses the list it is trying to sort and then chooses an approach based on the list.

Since the algorithm has been invented it has been used as the default sorting algorithm in Python, Java, the Android Platform, and in versions of GNU.

Timsort was designed to use already-ordered elements that already exist in most real-world data. It calls these already-ordered elements "natural runs". It iterates over the data collecting the elements into runs, and simultaneously merging those runs together into one.

# The array has fewer than 64 elements in it

If the array has fewer than 64 elements in it, timsort will execute an insertion sort.

An insertion sort is a simple sort which is most effective on small lists. It is quite slow at larger lists, but very fast with small lists. The idea of an insertion sort is as follows:

** Look at elements one by one
** Build up sorted list by inserting the element at the correct location

Here's a trace table showing how insertion sort would sort the list [34, 10, 64, 51, 32, 21]

|       [34, 10, 64, 51, 32, 21]       | No. shifted to right |
| ------------------------------------ | -------------------- |
| [34, 10, 64, 51, 32, 21]             | Nothing yet |
| [10, **34**, 64, 51, 32, 21]             | 34 |
| [**10**, **34**, 64, 51, 32, 21]         | Nothing yet |
| [**10**, **34**, **51**, 64, 32, 21]       | 64 |
| [**10**, **32**, **34**, **51**, **64**, 21]   | 34, 51, 64 |
| [**10**, **21**, **32**, **34**, **51**, **64**] | 32, 34, 51, 64 |

In this instance we are inserting the newly sorted elements into a new sub-array, which starts at the start of the array.

Here's a gif showing insertion sort:

![img](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif)

# More about runs

If the list is larger than 64 elements than the algorithm will make a first pass through the list looking for parts that are strictly increasing or decreasing. If the part is decreasing, it will reverse that part.

The minrun is a size which is determined based on the size of the array. It is selected so that most runs in a random array are, or become minrun, in length. Merging 2 arrays is more efficient when the number of runs is equal to, or slightly less than, a power of two. Timsort chooses minrun to try to ensure this efficiency.

Minrun is chosen from the range 32 to 64 inclusive, such that the length of the original array, when divided by minrun, is equal to or slightly less than a power of two. 

If the run is less than minrun, you calculate the length of that run away from minrun. Using this new number, you grab that many items ahead of the run and perform an insertion sort to create a new run.

After this part has completed we should now have a bunch of sorted runs in a list.

# Merging

Timsort now performs mergesort to merge the runs together, however, Timsort makes sure to maintain stabillity and merge balance whilest merge sorting.

In order to maintain stabillity we should not exchange 2 numbers of equal value. This not only keeps their original positions in the list but enables the algorithm to become faster.

As Timsort finds runs, it adds them to a stack. A simple stack would look like this:

| a |
| --- | 
| b |
| c |

Imagine a stack of plates. You cannot take plates from the bottom, so you have to take them from the top. The same is true about a stack.

Timsort tries to balance two competing needs when mergesort runs. On one hand, we would like to delay merging as long as possible in order to exploit patterns that may come up later. But we would like even more to do the merging as soon as possible to exploit the run that the run just found is still high in the memory hierachy. We also can't delay merging "too long" because it consumes memory to remember the runs that are stil unmerged, and the stack has a fixed size.

To make sure we have this compromise, Timsort keeps track of the three most recent items on the stack and creates two laws that must hold true of those items:

1. A > B + C
2. B > C

In the words of Tim Peters himself:

> What turned out to be a good compromise maintains two invariants on the stack entries, where A, B and C are the lengths of the three righmost not-yet merged slices



If A <= B+C, the smaller of A and C is merged with B (ties favor C, for the
freshness-in-cache reason), and the new run replaces the A,B or B,C entries;
e.g., if the last 3 entries are

    A:30  B:20  C:10



The thrust of these rules when they trigger merging is to balance the run
lengths as closely as possible, while keeping a low bound on the number of
runs we have to remember.  This is maximally effective for random data,
where all runs are likely to be of (artificially forced) length minrun, and
then we get a sequence of perfectly balanced merges (with, perhaps, some
oddballs at the end).

OTOH, one reason this sort is so good for partly ordered data has to do
with wildly unbalanced run lengths.


https://bugs.python.org/file4451/timsort.txt

We want to share memory among programs.

Each byte has its own address.

If we run this code:

```
start:
    add ecx, 1
    jump start
```

the ```start:``` is at memory address 100. By the time it reaches the jump start the program may have move in memory to memory address 115 which means it wont work. Compile time binding is where a program wont' get moved in memory.

# Load time binding

Ideally would like programs to run anywhere in memory

May be able to generate position independent code (PIC)

Aided by various modes:

pc-relative: jump to current pc value + 5
register-indexed: load

Various addressing mode let's us do things relative to the content of a register.

We can't always use position independent code. Some instructions require absolute addresses and not realtive addresses.

If not the program can include a list of instruction addresses that need to be inistalised by loader.

# Dynamic Run-Time Binding

Used in modern systems

We assume that every program will run at address 0. You can't run all programs at address 0.

For programs with address space of size N, all addresses are in range 0 to N-1. Program isn't going to run at address 0. These are logical addresses. At some point you have to convert these back to real physical addresses.

There are logical (virtual) assistants.

Mapping to physical addresses handled at run-time by CPU's memory management unit (MMU).

The MMU's job is to turn all logical addresses to physical addresses. In theory it'll add +100 to an address to get it at the right physical address.

# Logical and Physical Addresses

Addresses are generated by the CPU are known as logical addresses.

The set of all logical addresses generated by a program is known as the logical address space.

The addresses generated by the MMU are known as physical addresses,

The set of all these are called the physical address space.

The addresses generated by ompile-time binding and load time binding result in the logical adn the physical addresses at the saem time.

Store is allocated to programs in contiguous partitions from one end of the store to the other.

Each process has a base or datum (where it starts)

each process also has a limit (how big the program is, how much space or length it occupies)

# Loading programmes

we wait for programs to finish before bringing in big programs. We may also need to chose which partition to put a program into. This gives us selection policies, how do we select a partition to load a program.

Fragmentation is what happens when you put a 5kb file into a 6kb space, there is a 1kb fragmentation.

* first fit - choose first partition of suitable size
* best fit - choose smallest partition which is big enough
* worst fit - choose biggest partition
    - we want the worst fitting partition because it may not fragment so much.

It may not be any.

Fragmentation may be severe.

50% rule
    * for first fit if amount of memory allocated is N, then the amount unusable owing to fragmentation is 0.5N or half unusuable memory

Shortage of memory
arrising from fragmentation
may not be able to support enough users
may have dificuklty loading enough programs to obtain good job mix. we want a mix of input and calculation programs.

Imposes limitations on progra mstructure.
- not suitable for sharing routiens and data
- does not reflect high level language structures
- does not handle memory expansion as well

# swapping

Would like to start more programs than can fit into physical memory.

To eblae this, keep some program images on disk.

During shceduling, a process image may be swapped in and another swapped out to make room.

- also helps to prevent starvation

For efficieny may have dedicated swap space on disk.

however swapping whole processes adds considerably to time of context switch.

# Dynamic loading

Not always neccesary to load entire image

image can consist of
- main program
- error routines

dynamic loading allows us to load the bits we need. 

When a routine calls another routine it checks to see if it has been loaded.

# Linking

you integrate code you write with bits of code written by other people (compiler). 

Linking is the intregration of user code with system or 3rd part libraries.

**Static Linking**

Copies of the library are included in the ifnal binary program image.

Usually done after compilation. Compile program and the linker will bring in

**Dynamic linking**

Doesnt bring in bits of code it needs. Brings them in when the program runs and needs those routines.

# Memory Organisation

To ameliorate some of the software problems arising from the linear store, more complex memory models are used which roganise the store hierarchically.

we have some empty partitions

```
60k, 240k, 150k, 600k, 108k, 310k
```

It has a list of empty partitions in memory and were going to have a new program which requires 100k to run.

Let's say the system wants to put it into partition of 150k.

Different selection policies possible. Which selection policy is being applied?